nextflow_workflow {

    name "Test Subworkflow FASTQ_QC_TRIM_FILTER_SETSTRANDEDNESS"
    script "../main.nf"
    workflow "FASTQ_QC_TRIM_FILTER_SETSTRANDEDNESS"
    config "./nextflow.config"

    tag "subworkflows"
    tag "subworkflows_nfcore"
    tag "subworkflows/fastq_qc_trim_filter_setstrandedness"

    tag "bbmap/bbsplit"
    tag "cat"
    tag "cat/fastq"
    tag "fastqc"
    tag "fq/lint"
    tag "sortmerna"
    tag "ribodetector"
    tag "subworkflows/fastq_fastqc_umitools_trimgalore"
    tag "subworkflows/fastq_fastqc_umitools_fastp"
    tag "subworkflows/fastq_subsample_fq_salmon"

    test("homo_sapiens paired-end [fastq] fastp sortmerna") {

        when {
            workflow {
                """
                ch_reads = Channel.of([
                    [ id:'test', single_end:false, strandedness:'auto' ], // meta map
                    [
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/fastq/test_rnaseq_1.fastq.gz', checkIfExists: true),
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/fastq/test_rnaseq_2.fastq.gz', checkIfExists: true)
                    ]
                ])

                input[0] = ch_reads
                input[1] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)) // ch_fasta
                input[2] = Channel.of(file(params.modules_testdata_base_path + "genomics/homo_sapiens/genome/transcriptome.fasta", checkIfExists: true)) // ch_transcript_fasta
                input[3] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.gtf', checkIfExists: true)) // ch_gtf
                input[4] = []              // ch_salmon_index
                input[5] = []              // ch_sortmerna_index
                input[6] = []              // ch_bbsplit_index
                input[7] = Channel.of(file('https://raw.githubusercontent.com/biocore/sortmerna/v4.3.4/data/rRNA_databases/rfam-5.8s-database-id98.fasta', checkIfExists: true)) // ch_rrna_fastas
                input[8] = true            // skip_bbsplit
                input[9] = false           // skip_fastqc
                input[10] = false          // skip_trimming
                input[11] = true           // skip_umi_extract
                input[12] = true           // make_salmon_index
                input[13] = true           // make_sortmerna_index
                input[14] = 'fastp'        // trimmer
                input[15] = 10             // min_trimmed_reads
                input[16] = true           // save_trimmed
                input[17] = true           // remove_ribo_rna
                input[18] = 'sortmerna'    // ribo_removal_tool
                input[19] = null           // ribodetector_read_length (not needed for sortmerna)
                input[20] = false          // with_umi
                input[21] = 0              // umi_discard_read
                input[22] = 0.8            // stranded_threshold
                input[23] = 0.1            // unstranded_threshold
                input[24] = false          // skip_linting
                input[25] = true           // fastp_merge
                """
            }
        }

        then {
            def pelines1 = path(workflow.out.reads[0][1][0]).linesGzip
            def pelines2 = path(workflow.out.reads[0][1][1]).linesGzip

            // First part of each fq lint report line is a timestamp, remove it before snapshotting
            def processed_ribo_removal_lint_report = path(workflow.out.lint_log.find { entry -> entry[1].contains('fq_lint_after_ribo_removal')}?.getAt(1))
                .getText()
                .readLines()
                .collect { line -> line.split(' ', 2)[1] } // Split by the first space and take everything after it
                .join('\n') // Join the processed lines back into a single text block

            assertAll(
                { assert workflow.success },
                { assert pelines1.size() == 15996 },
                { assert pelines2.size() == 15996 },
                { assert workflow.out.trim_read_count[0][1] == 4999 },
                { assert snapshot(
                    pelines1.join('\n').md5(),
                    pelines2.join('\n').md5(),
                    processed_ribo_removal_lint_report
                ).match() }
            )
        }
    }

    test("homo_sapiens paired-end [fastq] fastp ribodetector") {

        when {
            workflow {
                """
                ch_reads = Channel.of([
                    [ id:'test', single_end:false, strandedness:'auto' ], // meta map
                    [
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/fastq/test_rnaseq_1.fastq.gz', checkIfExists: true),
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/fastq/test_rnaseq_2.fastq.gz', checkIfExists: true)
                    ]
                ])

                input[0] = ch_reads
                input[1] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)) // ch_fasta
                input[2] = Channel.of(file(params.modules_testdata_base_path + "genomics/homo_sapiens/genome/transcriptome.fasta", checkIfExists: true)) // ch_transcript_fasta
                input[3] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.gtf', checkIfExists: true)) // ch_gtf
                input[4] = []              // ch_salmon_index
                input[5] = []              // ch_sortmerna_index
                input[6] = []              // ch_bbsplit_index
                input[7] = []              // ch_rrna_fastas (not needed for ribodetector)
                input[8] = true            // skip_bbsplit
                input[9] = false           // skip_fastqc
                input[10] = false          // skip_trimming
                input[11] = true           // skip_umi_extract
                input[12] = true           // make_salmon_index
                input[13] = false          // make_sortmerna_index (not needed for ribodetector)
                input[14] = 'fastp'        // trimmer
                input[15] = 10             // min_trimmed_reads
                input[16] = true           // save_trimmed
                input[17] = true           // remove_ribo_rna
                input[18] = 'ribodetector' // ribo_removal_tool
                input[19] = 151            // ribodetector_read_length
                input[20] = false          // with_umi
                input[21] = 0              // umi_discard_read
                input[22] = 0.8            // stranded_threshold
                input[23] = 0.1            // unstranded_threshold
                input[24] = false          // skip_linting
                input[25] = true           // fastp_merge
                """
            }
        }

        then {
            def pelines1 = path(workflow.out.reads[0][1][0]).linesGzip
            def pelines2 = path(workflow.out.reads[0][1][1]).linesGzip

            // First part of each fq lint report line is a timestamp, remove it before snapshotting
            def processed_ribo_removal_lint_report = path(workflow.out.lint_log.find { entry -> entry[1].contains('fq_lint_after_ribo_removal')}?.getAt(1))
                .getText()
                .readLines()
                .collect { line -> line.split(' ', 2)[1] } // Split by the first space and take everything after it
                .join('\n') // Join the processed lines back into a single text block

            assertAll(
                { assert workflow.success },
                { assert pelines1.size() == 15996 },
                { assert pelines2.size() == 15996 },
                { assert workflow.out.trim_read_count[0][1] == 4999 },
                { assert snapshot(
                    pelines1.join('\n').md5(),
                    pelines2.join('\n').md5(),
                    processed_ribo_removal_lint_report
                ).match() }
            )
        }
    }

    test("homo_sapiens paired-end [fastq] trimgalore sortmerna") {

        when {
            workflow {
                """
                ch_reads = Channel.of([
                    [ id:'test', single_end:false, strandedness:'auto' ], // meta map
                    [
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/fastq/test_rnaseq_1.fastq.gz', checkIfExists: true),
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/fastq/test_rnaseq_2.fastq.gz', checkIfExists: true)
                    ]
                ])

                input[0] = ch_reads
                input[1] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)) // ch_fasta
                input[2] = Channel.of(file(params.modules_testdata_base_path + "genomics/homo_sapiens/genome/transcriptome.fasta", checkIfExists: true)) // ch_transcript_fasta
                input[3] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.gtf', checkIfExists: true)) // ch_gtf
                input[4] = []              // ch_salmon_index
                input[5] = []              // ch_sortmerna_index
                input[6] = []              // ch_bbsplit_index
                input[7] = Channel.of(file('https://raw.githubusercontent.com/biocore/sortmerna/v4.3.4/data/rRNA_databases/rfam-5.8s-database-id98.fasta', checkIfExists: true)) // ch_rrna_fastas
                input[8] = true            // skip_bbsplit
                input[9] = false           // skip_fastqc
                input[10] = false          // skip_trimming
                input[11] = true           // skip_umi_extract
                input[12] = true           // make_salmon_index
                input[13] = true           // make_sortmerna_index
                input[14] = 'trimgalore'   // trimmer
                input[15] = 10             // min_trimmed_reads
                input[16] = true           // save_trimmed
                input[17] = true           // remove_ribo_rna
                input[18] = 'sortmerna'    // ribo_removal_tool
                input[19] = null           // ribodetector_read_length (not needed for sortmerna)
                input[20] = false          // with_umi
                input[21] = 0              // umi_discard_read
                input[22] = 0.8            // stranded_threshold
                input[23] = 0.1            // unstranded_threshold
                input[24] = false          // skip_linting
                input[25] = true           // fastp_merge
                """
            }
        }

        then {
            def pelines1 = path(workflow.out.reads[0][1][0]).linesGzip
            def pelines2 = path(workflow.out.reads[0][1][1]).linesGzip

            // First part of each fq lint report line is a timestamp, remove it before snapshotting
            def processed_ribo_removal_lint_report = path(workflow.out.lint_log.find { entry -> entry[1].contains('fq_lint_after_ribo_removal')}?.getAt(1))
                .getText()
                .readLines()
                .collect { line -> line.split(' ', 2)[1] } // Split by the first space and take everything after it
                .join('\n') // Join the processed lines back into a single text block

            assertAll(
                { assert workflow.success },
                { assert pelines1.size() == 15996 },
                { assert pelines2.size() == 15996 },
                { assert workflow.out.trim_read_count[0][1] == 4999 },
                { assert snapshot(
                    pelines1.join('\n').md5(),
                    pelines2.join('\n').md5(),
                    processed_ribo_removal_lint_report
                ).match() }
            )
        }
    }

}
