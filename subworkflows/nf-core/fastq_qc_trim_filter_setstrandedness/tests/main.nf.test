
nextflow_workflow {

    name "Test Subworkflow FASTQ_QC_TRIM_FILTER_SETSTRANDEDNESS"
    script "../main.nf"
    workflow "FASTQ_QC_TRIM_FILTER_SETSTRANDEDNESS"
    config "./nextflow.config"

    tag "subworkflows"
    tag "subworkflows_nfcore"
    tag "subworkflows/fastq_qc_trim_filter_setstrandedness"

    tag "bbmap/bbsplit"
    tag "cat/fastq"
    tag "fastqc"
    tag "fq/lint"

    tag "subworkflows/fastq_remove_rrna"
    tag "subworkflows/fastq_fastqc_umitools_trimgalore"
    tag "subworkflows/fastq_fastqc_umitools_fastp"
    tag "subworkflows/fastq_subsample_fq_salmon"

    // Global setup: Inject synthetic rRNA reads into test data using CAT_FASTQ
    // The rRNA reads (from generic/fastq/) are 5.8S rRNA sequences that will be detected
    // by both SortMeRNA (alignment-based, 100% detection) and RiboDetector (ML-based, ~70% detection)
    setup {
        run("CAT_FASTQ") {
            script "../../../../modules/nf-core/cat/fastq/main.nf"
            process {
                """
                // CAT_FASTQ input: alternating R1/R2 files [r1_a, r2_a, r1_b, r2_b, ...]
                // Even indices -> R1 files, odd indices -> R2 files
                input[0] = Channel.of([
                    [ id:'test', single_end:false, strandedness:'auto' ],
                    [
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/fastq/test_rnaseq_1.fastq.gz', checkIfExists: true),
                        file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/fastq/test_rnaseq_2.fastq.gz', checkIfExists: true),
                        file(params.modules_testdata_base_path + 'generic/fastq/rrna_reads_1.fastq.gz', checkIfExists: true),
                        file(params.modules_testdata_base_path + 'generic/fastq/rrna_reads_2.fastq.gz', checkIfExists: true)
                    ]
                ])
                """
            }
        }
    }

    test("homo_sapiens paired-end [fastq] fastp sortmerna") {

        when {
            workflow {
                """
                // Input channels
                input[0] = CAT_FASTQ.out.reads
                input[1] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)) // ch_fasta
                input[2] = Channel.of(file(params.modules_testdata_base_path + "genomics/homo_sapiens/genome/transcriptome.fasta", checkIfExists: true)) // ch_transcript_fasta
                input[3] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.gtf', checkIfExists: true)) // ch_gtf
                input[4] = []              // ch_salmon_index
                input[5] = []              // ch_sortmerna_index
                input[6] = []              // ch_bowtie2_index
                input[7] = []              // ch_bbsplit_index
                input[8] = Channel.of(file('https://raw.githubusercontent.com/biocore/sortmerna/v4.3.4/data/rRNA_databases/rfam-5.8s-database-id98.fasta', checkIfExists: true)) // ch_rrna_fastas

                // Skip options
                input[9] = true            // skip_bbsplit
                input[10] = false          // skip_fastqc
                input[11] = false          // skip_trimming
                input[12] = true           // skip_umi_extract
                input[13] = false          // skip_linting

                // Index generation
                input[14] = true           // make_salmon_index
                input[15] = true           // make_sortmerna_index
                input[16] = false          // make_bowtie2_index

                // Trimming options
                input[17] = 'fastp'        // trimmer
                input[18] = 10             // min_trimmed_reads
                input[19] = true           // save_trimmed
                input[20] = true           // fastp_merge

                // rRNA removal options
                input[21] = true           // remove_ribo_rna
                input[22] = 'sortmerna'    // ribo_removal_tool

                // UMI options
                input[23] = false          // with_umi
                input[24] = 0              // umi_discard_read

                // Strandedness thresholds
                input[25] = 0.8            // stranded_threshold
                input[26] = 0.1            // unstranded_threshold
                """
            }
        }

        then {
            def pelines1 = path(workflow.out.reads[0][1][0]).linesGzip
            def pelines2 = path(workflow.out.reads[0][1][1]).linesGzip

            // First part of each fq lint report line is a timestamp, remove it before snapshotting
            def processed_ribo_removal_lint_report = path(workflow.out.lint_log_ribo[0][1])
                .getText()
                .readLines()
                .collect { line -> line.split(' ', 2)[1] } // Split by the first space and take everything after it
                .join('\n') // Join the processed lines back into a single text block

            // Parse sortmerna log for rRNA detection stats
            def sortmernaLog = path(workflow.out.multiqc_files.find { it.toString().endsWith('.sortmerna.log') })
                .getText()
            def sortmernaRrnaMatch = (sortmernaLog =~ /Total reads passing E-value threshold = (\d+)/)
            def sortmernaRrnaCount = sortmernaRrnaMatch ? sortmernaRrnaMatch[0][1].toInteger() : -1

            // Input: 4159 original + 10 synthetic rRNA = 4169 read pairs
            // After fastp merge: 1137 pairs (3022 merged reads)
            // SortMeRNA removes all 10 synthetic rRNA pairs (20 individual reads), leaving 1127 pairs
            assertAll(
                { assert workflow.success },
                { assert pelines1.size() == 4508 },  // 1127 pairs × 4 lines/read
                { assert pelines2.size() == 4508 },
                { assert workflow.out.trim_read_count[0][1] == 3022 },
                { assert sortmernaRrnaCount == 20 },  // 10 pairs = 20 individual reads (100% detection)
                { assert snapshot(
                    pelines1.join('\n').md5(),
                    pelines2.join('\n').md5(),
                    processed_ribo_removal_lint_report
                ).match() }
            )
        }
    }

    test("homo_sapiens paired-end [fastq] fastp ribodetector") {

        when {
            workflow {
                """
                // Input channels
                input[0] = CAT_FASTQ.out.reads
                input[1] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)) // ch_fasta
                input[2] = Channel.of(file(params.modules_testdata_base_path + "genomics/homo_sapiens/genome/transcriptome.fasta", checkIfExists: true)) // ch_transcript_fasta
                input[3] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.gtf', checkIfExists: true)) // ch_gtf
                input[4] = []              // ch_salmon_index
                input[5] = []              // ch_sortmerna_index
                input[6] = []              // ch_bowtie2_index
                input[7] = []              // ch_bbsplit_index
                input[8] = []              // ch_rrna_fastas (not needed for ribodetector)

                // Skip options
                input[9] = true            // skip_bbsplit
                input[10] = false          // skip_fastqc
                input[11] = false          // skip_trimming
                input[12] = true           // skip_umi_extract
                input[13] = false          // skip_linting

                // Index generation
                input[14] = true           // make_salmon_index
                input[15] = false          // make_sortmerna_index (not needed for ribodetector)
                input[16] = false          // make_bowtie2_index

                // Trimming options
                input[17] = 'fastp'        // trimmer
                input[18] = 10             // min_trimmed_reads
                input[19] = true           // save_trimmed
                input[20] = true           // fastp_merge

                // rRNA removal options
                input[21] = true           // remove_ribo_rna
                input[22] = 'ribodetector' // ribo_removal_tool

                // UMI options
                input[23] = false          // with_umi
                input[24] = 0              // umi_discard_read

                // Strandedness thresholds
                input[25] = 0.8            // stranded_threshold
                input[26] = 0.1            // unstranded_threshold
                """
            }
        }

        then {
            def pelines1 = path(workflow.out.reads[0][1][0]).linesGzip
            def pelines2 = path(workflow.out.reads[0][1][1]).linesGzip

            // First part of each fq lint report line is a timestamp, remove it before snapshotting
            def processed_ribo_removal_lint_report = path(workflow.out.lint_log_ribo[0][1])
                .getText()
                .readLines()
                .collect { line -> line.split(' ', 2)[1] } // Split by the first space and take everything after it
                .join('\n') // Join the processed lines back into a single text block

            // Parse ribodetector log for rRNA detection stats
            // Note: ribodetector log contains ANSI color codes that must be stripped before regex matching
            def ribodetectorLog = path(workflow.out.multiqc_files.find { it.toString().endsWith('.ribodetector.log') })
                .getText()
                .replaceAll(/\u001b\[[0-9;]*m/, '')  // Strip ANSI escape codes
            def ribodetectorRrnaMatch = (ribodetectorLog =~ /Detected (\d+) rRNA sequences/)
            def ribodetectorRrnaCount = ribodetectorRrnaMatch ? ribodetectorRrnaMatch[0][1].toInteger() : -1

            // Input: 4159 original + 10 synthetic rRNA = 4169 read pairs
            // After fastp merge: 1137 pairs (3022 merged reads)
            // RiboDetector removes 7 of 10 synthetic rRNA pairs (70% detection), leaving 1130 pairs
            assertAll(
                { assert workflow.success },
                { assert pelines1.size() == 4520 },  // 1130 pairs × 4 lines/read
                { assert pelines2.size() == 4520 },
                { assert workflow.out.trim_read_count[0][1] == 3022 },
                { assert ribodetectorRrnaCount == 7 },  // 7 pairs detected (70% - ML model misses some)
                { assert snapshot(
                    pelines1.join('\n').md5(),
                    pelines2.join('\n').md5(),
                    processed_ribo_removal_lint_report.md5()
                ).match() }
            )
        }
    }

    test("homo_sapiens paired-end [fastq] trimgalore sortmerna") {

        when {
            workflow {
                """
                // Input channels
                input[0] = CAT_FASTQ.out.reads
                input[1] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)) // ch_fasta
                input[2] = Channel.of(file(params.modules_testdata_base_path + "genomics/homo_sapiens/genome/transcriptome.fasta", checkIfExists: true)) // ch_transcript_fasta
                input[3] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.gtf', checkIfExists: true)) // ch_gtf
                input[4] = []              // ch_salmon_index
                input[5] = []              // ch_sortmerna_index
                input[6] = []              // ch_bowtie2_index
                input[7] = []              // ch_bbsplit_index
                input[8] = Channel.of(file('https://raw.githubusercontent.com/biocore/sortmerna/v4.3.4/data/rRNA_databases/rfam-5.8s-database-id98.fasta', checkIfExists: true)) // ch_rrna_fastas

                // Skip options
                input[9] = true            // skip_bbsplit
                input[10] = false          // skip_fastqc
                input[11] = false          // skip_trimming
                input[12] = true           // skip_umi_extract
                input[13] = false          // skip_linting

                // Index generation
                input[14] = true           // make_salmon_index
                input[15] = true           // make_sortmerna_index
                input[16] = false          // make_bowtie2_index

                // Trimming options
                input[17] = 'trimgalore'   // trimmer
                input[18] = 10             // min_trimmed_reads
                input[19] = true           // save_trimmed
                input[20] = true           // fastp_merge

                // rRNA removal options
                input[21] = true           // remove_ribo_rna
                input[22] = 'sortmerna'    // ribo_removal_tool

                // UMI options
                input[23] = false          // with_umi
                input[24] = 0              // umi_discard_read

                // Strandedness thresholds
                input[25] = 0.8            // stranded_threshold
                input[26] = 0.1            // unstranded_threshold
                """
            }
        }

        then {
            def pelines1 = path(workflow.out.reads[0][1][0]).linesGzip
            def pelines2 = path(workflow.out.reads[0][1][1]).linesGzip

            // First part of each fq lint report line is a timestamp, remove it before snapshotting
            def processed_ribo_removal_lint_report = path(workflow.out.lint_log_ribo[0][1])
                .getText()
                .readLines()
                .collect { line -> line.split(' ', 2)[1] } // Split by the first space and take everything after it
                .join('\n') // Join the processed lines back into a single text block

            // Parse sortmerna log for rRNA detection stats
            def sortmernaLog = path(workflow.out.multiqc_files.find { it.toString().endsWith('.sortmerna.log') })
                .getText()
            def sortmernaRrnaMatch = (sortmernaLog =~ /Total reads passing E-value threshold = (\d+)/)
            def sortmernaRrnaCount = sortmernaRrnaMatch ? sortmernaRrnaMatch[0][1].toInteger() : -1

            // Input: 4159 original + 10 synthetic rRNA = 4169 read pairs
            // After trimgalore: 4169 pairs (no merging, unlike fastp)
            // SortMeRNA removes all 10 synthetic rRNA pairs (20 individual reads), leaving 4159 pairs
            assertAll(
                { assert workflow.success },
                { assert pelines1.size() == 16636 },  // 4159 pairs × 4 lines/read
                { assert pelines2.size() == 16636 },
                { assert workflow.out.trim_read_count[0][1] == 4169.0 },
                { assert sortmernaRrnaCount == 20 },  // 10 pairs = 20 individual reads (100% detection)
                { assert snapshot(
                    pelines1.join('\n').md5(),
                    pelines2.join('\n').md5(),
                    processed_ribo_removal_lint_report.md5()
                ).match() }
            )
        }
    }

    test("homo_sapiens paired-end [fastq] fastp bowtie2") {

        when {
            workflow {
                """
                // Input channels
                input[0] = CAT_FASTQ.out.reads
                input[1] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)) // ch_fasta
                input[2] = Channel.of(file(params.modules_testdata_base_path + "genomics/homo_sapiens/genome/transcriptome.fasta", checkIfExists: true)) // ch_transcript_fasta
                input[3] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.gtf', checkIfExists: true)) // ch_gtf
                input[4] = []              // ch_salmon_index
                input[5] = []              // ch_sortmerna_index
                input[6] = []              // ch_bowtie2_index
                input[7] = []              // ch_bbsplit_index
                input[8] = Channel.of(file('https://raw.githubusercontent.com/biocore/sortmerna/v4.3.4/data/rRNA_databases/rfam-5.8s-database-id98.fasta', checkIfExists: true)) // ch_rrna_fastas

                // Skip options
                input[9] = true            // skip_bbsplit
                input[10] = false          // skip_fastqc
                input[11] = false          // skip_trimming
                input[12] = true           // skip_umi_extract
                input[13] = false          // skip_linting

                // Index generation
                input[14] = true           // make_salmon_index
                input[15] = false          // make_sortmerna_index (not needed for bowtie2)
                input[16] = true           // make_bowtie2_index

                // Trimming options
                input[17] = 'fastp'        // trimmer
                input[18] = 10             // min_trimmed_reads
                input[19] = true           // save_trimmed
                input[20] = true           // fastp_merge

                // rRNA removal options
                input[21] = true           // remove_ribo_rna
                input[22] = 'bowtie2'      // ribo_removal_tool

                // UMI options
                input[23] = false          // with_umi
                input[24] = 0              // umi_discard_read

                // Strandedness thresholds
                input[25] = 0.8            // stranded_threshold
                input[26] = 0.1            // unstranded_threshold
                """
            }
        }

        then {
            def pelines1 = path(workflow.out.reads[0][1][0]).linesGzip
            def pelines2 = path(workflow.out.reads[0][1][1]).linesGzip

            // First part of each fq lint report line is a timestamp, remove it before snapshotting
            def processed_ribo_removal_lint_report = path(workflow.out.lint_log_ribo[0][1])
                .getText()
                .readLines()
                .collect { line -> line.split(' ', 2)[1] } // Split by the first space and take everything after it
                .join('\n') // Join the processed lines back into a single text block

            // Parse bowtie2 log for alignment stats - count mates that aligned to rRNA
            def bowtie2Log = path(workflow.out.multiqc_files.find { it.toString().endsWith('.bowtie2.log') })
                .getText()
            def exactMatch = (bowtie2Log =~ /(\d+) \(\d+\.\d+%\) aligned exactly 1 time/)
            def multiMatch = (bowtie2Log =~ /(\d+) \(\d+\.\d+%\) aligned >1 times/)
            def exactCount = exactMatch ? exactMatch[0][1].toInteger() : 0
            def multiCount = multiMatch ? multiMatch[0][1].toInteger() : 0
            def bowtie2RrnaCount = exactCount + multiCount

            // Input: 4159 original + 10 synthetic rRNA = 4169 read pairs
            // After fastp merge: 1137 pairs (3022 merged reads)
            // Bowtie2 aligns 17 individual mates to rRNA (vs SortMeRNA's 20 - less sensitive)
            // These 17 mates come from 10 pairs: 7 pairs had both mates align, 3 pairs had one mate align
            // Using samtools -f 12 removes any pair where EITHER mate aligned, leaving 1127 pairs
            // (same result as SortMeRNA despite detecting fewer individual mates)
            assertAll(
                { assert workflow.success },
                { assert pelines1.size() == 4508 },  // 1127 pairs × 4 lines/read
                { assert pelines2.size() == 4508 },
                { assert workflow.out.trim_read_count[0][1] == 3022 },
                { assert bowtie2RrnaCount == 17 },  // 17 mates aligned to rRNA reference
                { assert snapshot(
                    pelines1.join('\n').md5(),
                    pelines2.join('\n').md5(),
                    processed_ribo_removal_lint_report.md5()
                ).match() }
            )
        }
    }

    test("homo_sapiens single-end [fastq] fastp bowtie2") {

        setup {
            run("CAT_FASTQ", alias: "CAT_FASTQ_SE") {
                script "../../../../modules/nf-core/cat/fastq/main.nf"
                process {
                    """
                    // Single-end test data with synthetic rRNA reads
                    input[0] = Channel.of([
                        [ id:'test_se', single_end:true, strandedness:'auto' ],
                        [
                            file(params.modules_testdata_base_path + 'genomics/homo_sapiens/illumina/fastq/test_rnaseq_1.fastq.gz', checkIfExists: true),
                            file(params.modules_testdata_base_path + 'generic/fastq/rrna_reads_1.fastq.gz', checkIfExists: true)
                        ]
                    ])
                    """
                }
            }
        }

        when {
            workflow {
                """
                // Input channels - wrap single file in list to match expected format
                input[0] = CAT_FASTQ_SE.out.reads.map { meta, reads -> [meta, reads instanceof List ? reads : [reads]] }
                input[1] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.fasta', checkIfExists: true)) // ch_fasta
                input[2] = Channel.of(file(params.modules_testdata_base_path + "genomics/homo_sapiens/genome/transcriptome.fasta", checkIfExists: true)) // ch_transcript_fasta
                input[3] = Channel.of(file(params.modules_testdata_base_path + 'genomics/homo_sapiens/genome/genome.gtf', checkIfExists: true)) // ch_gtf
                input[4] = []              // ch_salmon_index
                input[5] = []              // ch_sortmerna_index
                input[6] = []              // ch_bowtie2_index
                input[7] = []              // ch_bbsplit_index
                input[8] = Channel.of(file('https://raw.githubusercontent.com/biocore/sortmerna/v4.3.4/data/rRNA_databases/rfam-5.8s-database-id98.fasta', checkIfExists: true)) // ch_rrna_fastas

                // Skip options
                input[9] = true            // skip_bbsplit
                input[10] = false          // skip_fastqc
                input[11] = false          // skip_trimming
                input[12] = true           // skip_umi_extract
                input[13] = false          // skip_linting

                // Index generation
                input[14] = true           // make_salmon_index
                input[15] = false          // make_sortmerna_index (not needed for bowtie2)
                input[16] = true           // make_bowtie2_index

                // Trimming options
                input[17] = 'fastp'        // trimmer
                input[18] = 10             // min_trimmed_reads
                input[19] = true           // save_trimmed
                input[20] = false          // fastp_merge (not applicable for single-end)

                // rRNA removal options
                input[21] = true           // remove_ribo_rna
                input[22] = 'bowtie2'      // ribo_removal_tool

                // UMI options
                input[23] = false          // with_umi
                input[24] = 0              // umi_discard_read

                // Strandedness thresholds
                input[25] = 0.8            // stranded_threshold
                input[26] = 0.1            // unstranded_threshold
                """
            }
        }

        then {
            // For single-end, reads output is a single file, not a list
            def selines = path(workflow.out.reads[0][1]).linesGzip

            // First part of each fq lint report line is a timestamp, remove it before snapshotting
            def processed_ribo_removal_lint_report = path(workflow.out.lint_log_ribo[0][1])
                .getText()
                .readLines()
                .collect { line -> line.split(' ', 2)[1] }
                .join('\n')

            // Parse bowtie2 log for alignment stats
            def bowtie2Log = path(workflow.out.multiqc_files.find { it.toString().endsWith('.bowtie2.log') })
                .getText()
            def exactMatch = (bowtie2Log =~ /(\d+) \(\d+\.\d+%\) aligned exactly 1 time/)
            def multiMatch = (bowtie2Log =~ /(\d+) \(\d+\.\d+%\) aligned >1 times/)
            def exactCount = exactMatch ? exactMatch[0][1].toInteger() : 0
            def multiCount = multiMatch ? multiMatch[0][1].toInteger() : 0
            def bowtie2RrnaCount = exactCount + multiCount

            // Input: 4159 original reads + 10 synthetic rRNA = 4169 reads
            // After fastp trimming: 4162 reads (7 removed by quality filtering)
            // Bowtie2 aligns 10 reads to rRNA (all with multiple alignments)
            // Using --un-gz outputs unmapped reads directly: 4152 reads remain
            assertAll(
                { assert workflow.success },
                { assert selines.size() == 16608 },  // 4152 reads × 4 lines/read
                { assert workflow.out.trim_read_count[0][1] == 4162 },
                { assert bowtie2RrnaCount == 10 },   // 10 reads aligned to rRNA reference
                { assert snapshot(
                    selines.join('\n').md5(),
                    processed_ribo_removal_lint_report.md5()
                ).match() }
            )
        }
    }

}
