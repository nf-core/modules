nextflow_workflow {

    name "Test Workflow VCF_IMPUTE_GLIMPSE"
    script "../main.nf"
    workflow "VCF_IMPUTE_GLIMPSE"

    config "./nextflow.config"

    tag "subworkflows"
    tag "bcftools/index"
    tag "subworkflows_nfcore"
    tag "subworkflows/vcf_impute_glimpse"
    tag "glimpse/phase"
    tag "glimpse/ligate"
    tag "glimpse/chunk"

    test("homo_sapiens - vcf no sample, panel vcf region, no chunks, no map, chunking") {
        when {
            params {
                outdir = "tests/results"
            }
            workflow {
                """
                input[0] = channel.of([
                    [id:'input_vcf'],
                    file(params.modules_testdata_base_path + "genomics/homo_sapiens/illumina/vcf/NA12878.chr22.1X.vcf.gz", checkIfExists: true),
                    file(params.modules_testdata_base_path + "genomics/homo_sapiens/illumina/vcf/NA12878.chr22.1X.vcf.gz.csi", checkIfExists: true),
                    []
                ]) // input
                input[1] = channel.of([
                    [panel:'ref_panel', chr: "22"],
                    file(params.modules_testdata_base_path + "genomics/homo_sapiens/popgen/1000GP.chr22.vcf.gz", checkIfExists:true),
                    file(params.modules_testdata_base_path + "genomics/homo_sapiens/popgen/1000GP.chr22.vcf.gz.csi", checkIfExists:true),
                    "chr22"
                ]) // reference
                input[2] = channel.of([
                    [panel: 'ref_panel', chr: "22"],
                    [], []
                ]) // chunks
                input[3] = channel.of([
                    [panel: 'ref_panel', chr: "22"],
                    []
                ]) // map
                input[4] = true // perform chunking
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success },
                { assert snapshot(
                    workflow.out.versions,
                    workflow.out.chunks,
                    workflow.out.vcf_index.collect{ meta, vcf, index -> [
                        meta,
                        path(vcf).getFileName().toString(),
                        path(index).getFileName().toString(),
                        path(vcf).vcf.summary,
                        path(vcf).vcf.header.getGenotypeSamples().sort(),
                        path(vcf).vcf.variantsMD5
                    ]}
                ).match() }
            )
        }

    }

    test("homo_sapiens - vcf and sample, panel vcf region, chunks, map, no chunking") {
        when {
            params {
                outdir = "tests/results"
            }
            workflow {
                """
                input[0] = channel.of([
                    [id:'input_vcf'],
                    file(params.modules_testdata_base_path + "genomics/homo_sapiens/illumina/vcf/NA12878.chr22.1X.vcf.gz", checkIfExists: true),
                    file(params.modules_testdata_base_path + "genomics/homo_sapiens/illumina/vcf/NA12878.chr22.1X.vcf.gz.csi", checkIfExists: true),
                    []
                ]) // input
                input[1] = channel.of([
                    [panel:'ref_panel', chr: "22"],
                    file(params.modules_testdata_base_path + "genomics/homo_sapiens/popgen/1000GP.chr22.vcf.gz", checkIfExists:true),
                    file(params.modules_testdata_base_path + "genomics/homo_sapiens/popgen/1000GP.chr22.vcf.gz.csi", checkIfExists:true),
                    "chr22"
                ]) // reference
                input[2] = channel.of(
                    [[panel: 'ref_panel', chr: "22"], "chr22:16570065-16597215", "chr22:16570065-16592216"],
                    [[panel: 'ref_panel', chr: "22"], "chr22:16587172-16609999", "chr22:16592229-16609999"]
                ) // chunks
                input[3] = channel.of([
                    [panel: 'ref_panel', chr: "22"],
                    file(params.modules_testdata_base_path + "genomics/homo_sapiens/genome/genetic_map/genome.GRCh38.chr22.glimpse.map", checkIfExists: true)
                ]) // map
                input[4] = false // perform chunking
                """
            }
        }

        then {
            assertAll(
                { assert workflow.success },
                { assert snapshot(
                    workflow.out.versions,
                    workflow.out.chunks,
                    workflow.out.vcf_index.collect{ meta, vcf, index -> [
                        meta,
                        path(vcf).getFileName().toString(),
                        path(index).getFileName().toString(),
                        path(vcf).vcf.summary,
                        path(vcf).vcf.header.getGenotypeSamples().sort(),
                        path(vcf).vcf.variantsMD5
                    ]}
                ).match() }
            )
        }

    }

    test("homo_sapiens - stub test") {
        options "-stub"
        when {
            workflow {
                """
                input[0] = channel.of([ [id:'input_vcf'], [], [], [] ]) // input
                input[1] = channel.of([ [panel:'ref_panel', chr: "22"], [], [], "chr22"]) // reference
                input[2] = channel.of(
                    [[panel: 'ref_panel', chr: "22"], "chr22:16570065-16597215", "chr22:16570065-16592216"],
                    [[panel: 'ref_panel', chr: "22"], "chr22:16587172-16609999", "chr22:16592229-16609999"]
                )
                input[3] = channel.of([ [panel: 'ref_panel', chr: "22"], [] ]) // Map
                input[4] = false // perform chunking
                """
            }
        }
        then {
            assertAll(
                { assert workflow.success },
                { assert snapshot(workflow.out).match() }
            )
        }
    }

    test("homo_sapiens - error chunks provided and chunk is true") {
        options "-stub"
        when {
            workflow {
                """
                input[0] = channel.of([ [id:'input_vcf'], [], [], [] ]) // input
                input[1] = channel.of([ [panel:'ref_panel', chr: "22"], [], [], "chr22"]) // reference
                input[2] = channel.of(
                    [[panel: 'ref_panel', chr: "22"], "chr22:16570065-16597215", "chr22:16570065-16592216"],
                    [[panel: 'ref_panel', chr: "22"], "chr22:16587172-16609999", "chr22:16592229-16609999"]
                ) // chunks
                input[3] = channel.of([ [panel: 'ref_panel', chr: "22"], [] ]) // Map
                input[4] = true // perform chunking
                """
            }
        }
        then {
            assertAll(
                { assert workflow.failed },
                { assert workflow.errorMessage.contains("ERROR: Cannot provide pre-defined chunks (regionin) when chunk=true. Please either set chunk=false to use provided chunks, or remove input chunks to enable automatic chunking.") }
            )
        }
    }

    test("homo_sapiens - error no chunks provided and chunk is false") {
        options "-stub"
        when {
            workflow {
                """
                input[0] = channel.of([ [id:'input_vcf'], [], [], [] ]) // input
                input[1] = channel.of([ [panel:'ref_panel', chr: "22"], [], [], "chr22"]) // reference
                input[2] = channel.of([ [panel: 'ref_panel', chr: "22"], [], [] ]) // chunks
                input[3] = channel.of([ [panel: 'ref_panel', chr: "22"], [] ]) // map
                input[4] = false // perform chunking
                """
            }
        }
        then {
            assertAll(
                { assert workflow.failed },
                { assert workflow.errorMessage.contains("ERROR: ch_chunks channel is empty. Please provide a valid channel or set chunk parameter to true.") }
            )
        }
    }

    test("homo_sapiens - error empty joint") {
        options "-stub"
        when {
            workflow {
                """
                input[0] = channel.of([ [id:'input_vcf'], [], [], [] ]) // input
                input[1] = channel.of([ [panel:'ref_panel', chr: "22"], [], [], "chr22"]) // reference
                input[2] = channel.of(
                    [[panel: 'ref_panel', chr: "22"], "chr22:16570065-16597215", "chr22:16570065-16592216"],
                    [[panel: 'ref_panel', chr: "22"], "chr22:16587172-16609999", "chr22:16592229-16609999"]
                ) // chunks
                input[3] = channel.of([ [panel: 'ref_panel_1', chr: "22"], [] ]) // Wrong panel
                input[4] = false // perform chunking
                """
            }
        }
        then {
            assertAll(
                { assert workflow.failed },
                { assert workflow.errorMessage.contains("ERROR: join operation resulted in an empty channel. Please provide a valid ch_chunks and ch_map channel as input.") }
            )
        }
    }

}
